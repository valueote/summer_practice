Huffman 树解压缩

### 使用编码树进行编码和解码

首先，让我们练习使用编码树解码一个位序列。下面的图示是字符 O、N、M 和 S 的编码树。每个叶节点对应一个字符。从根到叶节点的路径跟踪了编码该字符的位序列。在图中，我们用 \* 标记了内部节点以便于可视化；但内部节点不存储字符，从根到内部节点的路径只是部分编码路径。

```
         *
        / \
       *   O
      / \
     N   *
        / \
       M   S
```

我们将左分支标记为零，右分支标记为一。从根节点到叶节点 S 的路径是左-右-右，对应的位序列为 011。

### 平坦化和展开编码树

Huffman 编码的一个实际问题是，压缩数据必须包括使用的编码树的信息，因为该编码对于输入数据是唯一的。没有原始编码树的信息，无法解码位序列。

我们想将 Huffman 树写入压缩文件，但不能直接写入树。因此，必须想出一种方法将树“平坦化”成一种能记录树的结构和数据的形式，从而可以在以后重建树。

一种简洁的方法是将树概括为两个序列：给出树形状的位序列和对应树叶的字符序列。

树的形状按如下方式平坦化为位序列：

- 如果树的根是一个叶节点，则用 0 表示。
- 如果树的根不是叶节点，则用 1 表示，后面跟着它的零（左）子树的平坦版本，然后是它的一（右）子树的平坦版本。
- 位序列按照树节点在先序遍历中被访问的顺序描述树结构。

树叶通过在中序遍历期间列出被访问的叶节点的字符来平坦化为一个字符序列。

两个平坦化的序列一起描述了树的形状和数据，从而可以以后重建原始树。

例如，左侧和中间的两个编码树如下所示，标记了平坦的位序列和字符序列：

```
      *                          *
    /   \                      /   \
   E     *                    A     *
        / \                        /  \
       W   K                      *    N
                                 / \
                                D   B

10100                       1011000
EWK                         ADBN
```

平坦化操作将树形写入 Queue<bit>，将叶节点写入 Queue<char>。展开操作采用两个队列并使用它们重建编码树。

### 生成最优 Huffman 树

在运行 Huffman 算法时，你可能会遇到具有相同权重的多个节点/子树，因此出现平局。算法可以任意打破平局。这意味着对于给定字符串，可能有许多同样最优的 Huffman 树，仅在算法打破平局的方式上有所不同。交换任何内部节点的零/一子树将创建一个镜像但也同样最优的结果。任何结果树都被视为正确的。

Huffman 编码是一种由 David Huffman 于 1952 年发明的数据压缩算法。这种简单而优雅的方法非常强大，以至于其变体至今仍在计算机网络、传真机、调制解调器、高清电视等领域中使用。你定会对其巧妙使用树结构并实现如此实用工具的能力感到印象深刻！

### 代码实现

在正式开始之前，请熟悉一下起始项目中的文件和提供给你的内容。以下是一些详细信息，以帮助你熟悉这些内容：

- **treenode.h** 定义了你将在编码树中使用的节点类型 `EncodedTreeNode` 结构体。你在预热练习中已介绍过这种类型。
- **bits.h** 定义了表示 0 或 1 的单一值的 `Bit` 类型。`Bit` 可以与整数 0 和 1 互换使用：

  ```cpp
  Queue<Bit> q;
  Bit b = 0;
  q.enqueue(0);
  if (q.dequeue() == 1) { }
  ```

  `Bit` 的特殊功能是它仅允许值 0 或 1。任何其他值都会引发错误（这是过去一个非常常见的错误，也是问题的根源之一，因此我们引入了这种受限类型来帮助你避免这些问题）。

- **bits.h** 还定义了存储在 Huffman 压缩文件中的数据的 `EncodedData` 结构体。在 **bits.cpp** 中，我们提供了读写位流的代码,代码使用了 C++的位操作功能。
- **main.cpp** 包含一个交互式控制台主程序，通过调用你的函数来进行端到端的文件压缩和解压缩。
- **huffman.cpp** 是你将实现 Huffman 压缩和解压缩所需功能并添加测试用例的地方。

在构建 Huffman 编码树时，你需要一个优先队列，标准库中的 `priorityqueue.h` 提供了一个通用的 `PriorityQueue`，实现为高效的二叉最小堆。它被定义为模板，并能存储客户端选择的元素类型，并且它使用 `double` 类型的优先级而非 `int`。请查阅 `PriorityQueue` 的文档以了解更多详细信息。特别是，确保你知道如何添加和删除元素以及如何确定相关项的优先级。你存储在优先队列中的元素将是树；具体来说，就是 `EncodingTreeNode*` 类型的元素。

### 策略

最终目标是开发一个完整的压缩和解压缩流水线，但如果按步骤分开开发，将这项任务分解成几部分，然后逐步完成，你的工作会更易于管理。我们将项目拆解为许多辅助函数，并提出了一种自底向上的实现顺序，先编写和测试各个函数，然后再将它们组合成最终的程序。

我们建议你首先处理解码/展开/解压缩任务。这看起来可能有点倒退，但事实证明这是一个很好的策略。解码/解压缩的代码比编码/压缩要简单一点，而且验证输出正确性更直接，因为它恢复了原始文本。

然后，当你移动到实现编码/展开/压缩，已经有一个完整可用的解码/解压缩管道，这意味着你可以将编码操作的输出反馈到解码进行测试。

当解压缩和压缩都可以工作时，你可以使用我们提供的主程序进行端到端文件压缩和解压缩，然后对你所创建的令人印象深刻的工具感到自豪！

### 解码/解压缩

按以下顺序实现功能：

#### `string decodeText(EncodingTreeNode* tree, Queue<Bit>& messageBits)`

`decodeText` 函数是一个很好的入门函数来编写操作树的代码。要复习使用树进行解码，请查看预热练习的 Q1。务必测试！起始代码有一个提供的 `decodeText` 测试，你可以通过增加测试用例来实现全面覆盖。

#### `EncodingTreeNode* unflattenTree(Queue<Bit>& treeShape, Queue<char>& treeLeaves)`

如果需要，可以回顾预热练习的 Q5 以在纸上练习展开操作，然后再尝试编码 `unflattenTree`。这个任务全在于树的遍历和树的构建。

#### `string decompress(EncodedData& data)`

最后的 `decompress` 函数听起来很困难，但你已经完成了所有的困难工作，剩下的只是将这些函数串联在一起。使用你从预热练习中获得的相同树，可能是一些简单的测试用例的好候选者。

### 解码神秘文件

现在有了一个可以工作的 `decompress` 函数，用它来解压缩我们包含在起始项目中的压缩文件吧。

运行你的程序，当主菜单提示你运行哪些测试时，选择 0（无）。现在主程序进入一个简单的控制台程序，允许你选择要压缩或解压缩的文件。起始项目包含一个你可以用来试验解压缩功能的压缩文件。

当提示你输入文件名时，指定相对于项目文件夹的名称，例如 `res/mystery.jpg.huf`（Windows 使用反斜杠 `res\mystery.jpg.huf`）。未压缩版本将被写入名为 `res/unhuf.mystery.jpg` 的文件。打开未压缩的文件以确认你成功地还原了原始文件。真是太神奇了！

### 编码/压缩

我们建议按以下顺序实现功能：

#### `Queue<Bit> encodeText(EncodingTreeNode* tree, string text)`

如果你首先遍历树并构建一个将每个字符与其编码的比特序列关联的映射表，实现 `encodeText` 会容易得多。然后你可以通过从映射表中访问其比特序列来编码字符，而不必反复遍历树来查找它。将 `encodeText` 和 `decodeText` 配对使用，可以进行回环测试。

#### `void flattenTree(EncodingTreeNode* tree, Queue<Bit>& treeShape, Queue<char>& treeLeaves)`

这个函数涉及更多的树遍历——写完 `flattenTree` 后，你将成为树遍历专家！一个好的测试是展开一棵树，然后通过 `unflatten`

### 实现编码/压缩功能

实现函数：

1. **Queue<Bit> encodeText(EncodingTreeNode\* tree, string text)**
   先遍历树并构建一个关联每个字符与其编码比特序列的映射，然后通过访问映射中的比特序列来编码字符，而不是反复遍历树寻找它。配对使用 encodeText 和 decodeText 可以进行回环测试。

2. **void flattenTree(EncodingTreeNode\* tree, Queue<Bit>& treeShape, Queue<char>& treeLeaves)**
   回顾 warmup 的 Q4，练习树的扁平化操作。这个函数涉及更多的树遍历操作。完成 flattenTree 后，你将成为树遍历专家。一个好的测试是将树扁平化并通过 unflatten 反转，确认输入和输出树是否相等。

3. **EncodingTreeNode\* buildHuffmanTree(string text)**
   buildHuffmanTree 函数是整个程序的核心。它接受输入文本并遵循霍夫曼算法构建一个针对输入文本的最优霍夫曼编码树。你可以在 warmup 的 Q6 中练习这一任务。

   准备好测试此函数时，请记住，对于给定的输入，可以有许多有效的霍夫曼树，它们在算法如何打破平局上可能有所不同。构建测试用例时，务必考虑如何打破平局会影响树的结果。避免因树与预期输出不符而陷入困境，才发现你的树是有效且同样最优的，但只是与你预想的不同。

4. **EncodedData compress(string messageText)**
   这个最终的 compress 函数将上述操作结合在一起成为一个完整的整体。通过 compress -> decompress 处理输入的测试用例应该能重构原始文本，并允许你确认整个流程的功能。你也可以使用控制台主程序来尝试压缩和解压文件。

**规范**

- 个别函数的文档（如 decode，unflatten 等）指出了你可以假设输入是有效且格式正确的。即便如此，编写代码时最好仍具备防御性。如果检查所需的假设并在违反时引发错误，这可能会在以后帮助你。我们不会测试无效输入，但在开发过程中，你可能会意外地给函数提供错误的输入。防御性编程可以节省调试错误测试用例的时间。
- 应能够处理任何字符组成的输入，而不仅仅是字母、数字等。许多文件，尤其是包含非文本数据（如声音和图像）的文件，使用了从 0 到 255 的所有可能字符值，因此不得限制可接受字符的范围。
- 要压缩的输入必须包含至少两个不同的字符，以使霍夫曼编码可行。如果给定的输入不满足此要求，你应拒绝并报告错误。

**测试**
starter 代码包括提供的测试，测试每个函数在简单已知输入上的基本操作。这些测试适合早期测试。你应补充其他小型测试用例，同样非常有针对性。
手动构建大规模测试很繁琐，不推荐。当准备进行更全面的测试时，改为使用跨越完整 compress -> decompress 循环的端到端测试策略。提供的主控制台程序可以运行 compress -> decompress 处理文件，这比手动构建更大更丰富的测试输入更容易访问。
实现应足够健壮，可以压缩所有类型的文件：文本、二进制、图像，甚至是已压缩的文件。程序可能无法进一步压缩已压缩文件（实际上，可能会变大，因为添加了扁平树的额外开销），但应能多次压缩、多次解压，并返回原始文件。
哪些类型的文件霍夫曼编码可以实现特别好的压缩？哪些类型的文件效果不佳？是否有文件在霍夫曼编码时会变大而不是缩小？创建样本文件测试你的理论。

### 扩展

基于霍夫曼编码的许多其他技术可以实现更好的数据压缩。以下是一些可以了解的概念：

- **自适应霍夫曼编码**：霍夫曼编码通过查看整个要压缩的文本来工作，找到每个字符的全局频率，然后构建一个单一的编码树。然而，在某些文件中，尤其是图像数据，不同区域的文件可能会有截然不同的字符频率。例如，在一幅黄向日葵对着明亮蓝天的图片中，存储天空数据的部分文件将主要用于存储不同的蓝色阴影，而存储向日葵的部分则主要用于存储黄色阴影。对于这种模式。
