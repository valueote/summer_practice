# Huffman 树解压缩

Huffman 编码是一种由 David Huffman 于 1952 年发明的数据压缩算法。这种简单而优雅的方法非常强大，以至于其变体至今仍在计算机网络、传真机、调制解调器、高清电视等领域中使用。你定会对其巧妙使用树结构并实现如此实用工具的能力感到印象深刻！

## 原理

### 使用编码树进行编码和解码

首先，让我们练习使用编码树解码一个位序列。下面的图示是字符 O、N、M 和 S 的编码树。每个叶节点对应一个字符。从根到叶节点的路径跟踪了编码该字符的位序列。在图中，我们用 \* 标记了内部节点以便于可视化；但内部节点不存储字符，从根到内部节点的路径只是部分编码路径。

```
         *
        / \
       *   O
      / \
     N   *
        / \
       M   S
```

我们将左分支标记为零，右分支标记为一。从根节点到叶节点 S 的路径是左-右-右，对应的位序列为 011。

### 平坦化和展开编码树

Huffman 编码的一个实际问题是，压缩数据必须包括使用的编码树的信息，因为该编码对于输入数据是唯一的。没有原始编码树的信息，解码位序列是不可能的。

我们想将 Huffman 树写入压缩文件，但是直接写出树是不可能的。因此，必须想出一种方法将树“平坦化”成一种能记录树的结构和数据的形式，从而可以在以后重建树。

一种简洁的方法是将树概括为两个序列：给出树形状的位序列和对应树叶的字符序列。

树的形状按如下方式平坦化为位序列：

- 如果树的根是一个叶节点，则用 0 表示。
- 如果树的根不是叶节点，则用 1 表示，后面跟着它的零（左）子树的平坦版本，然后是它的一（右）子树的平坦版本。
- 位序列按照树节点在先序遍历中被访问的顺序描述树结构。

树叶通过在中序遍历期间列出被访问的叶节点的字符来平坦化为一个字符序列。

两个平坦化的序列一起描述了树的形状和数据，从而可以以后重建原始树。

例如，左侧和中间的两个编码树如下所示，标记了平坦的位序列和字符序列：

```
      *                          *
    /   \                      /   \
   E     *                    A     *
        / \                        /  \
       W   K                      *    N
                                 / \
                                D   B

10100                       1011000
EWK                         ADBN
```

平坦化操作将树形写入 Queue<bit>，将叶节点写入 Queue<char>。展开操作采用两个队列并使用它们重建编码树。

### 生成最优 Huffman 树

在运行 Huffman 算法时，你可能会遇到具有相同权重的多个节点/子树，因此出现平局。算法可以任意打破平局。这意味着对于给定字符串，可能有许多同样最优的 Huffman 树，仅在算法打破平局的方式上有所不同。交换任何内部节点的零/一子树将创建一个镜像但也同样最优的结果。任何结果树都被视为正确的。

## 代码实现

- **treenode.h** 定义了在编码树中使用的节点类型 `EncodedTreeNode` 结构体。
- **bits.h** 定义了表示 0 或 1 的单一值的 `Bit` 类型。`Bit` 可以与整数 0 和 1 互换使用：

  ```cpp
  Queue<Bit> q;
  Bit b = 0;
  q.enqueue(0);
  if (q.dequeue() == 1) { }
  ```

  `Bit` 的特殊功能是它仅允许值 0 或 1。任何其他值都会引发错误。

- **bits.h** 还定义了存储在 Huffman 压缩文件中的数据的 `EncodedData` 结构体。在 **bits.cpp** 中，有读写位流的代码,代码使用了 C++的位操作功能。
- **main.cpp** 包含一个交互式控制台主程序，通过调用函数来进行端到端的文件压缩和解压缩。
- **huffman.cpp** 是实现 Huffman 压缩和解压缩所需功能并添加测试用例的地方。

在构建 Huffman 编码树时，需要一个优先队列，标准库中的 `priorityqueue.h` 提供了一个通用的 `PriorityQueue`，实现为高效的二叉最小堆。它被定义为模板，并能存储客户端选择的元素类型，并且它使用 `double` 类型的优先级而非 `int`。请查阅 `PriorityQueue` 的文档以了解更多详细信息。特别是，确保你知道如何添加和删除元素以及如何确定相关项的优先级。你存储在优先队列中的元素将是树；具体来说，就是 `EncodingTreeNode*` 类型的元素。

### 解码/解压缩

按以下顺序实现功能：

#### `string decodeText(EncodingTreeNode* tree, Queue<Bit>& messageBits)`

- 给定一个包含压缩位信息的 Queue<Bit>与一个用于编码这些位的编码树，将位解码为原来的信息。

#### `EncodingTreeNode* unflattenTree(Queue<Bit>& treeShape, Queue<char>& treeLeaves)`

- 根据平铺形式的 Queue<bit>与 Queue<char>重构编码树

#### `string decompress(EncodedData& data)`

- 将给定的编码数据解压缩并返回原有的文本。

### 编码/压缩

实现功能：

#### `Queue<Bit> encodeText(EncodingTreeNode* tree, string text)`

如果你首先遍历树并构建一个将每个字符与其编码的比特序列关联的映射表，实现 `encodeText` 会容易得多。然后你可以通过从映射表中访问其比特序列来编码字符，而不必反复遍历树来查找它。将 `encodeText` 和 `decodeText` 配对使用，可以进行回环测试。

#### `void flattenTree(EncodingTreeNode* tree, Queue<Bit>& treeShape, Queue<char>& treeLeaves)`

这个函数涉及更多的树遍历——写完 `flattenTree` 后，你将成为树遍历专家！一个好的测试是展开一棵树，然后通过 `unflatten`

### 实现编码/压缩功能

实现函数：

1. **Queue<Bit> encodeText(EncodingTreeNode\* tree, string text)**
   给定一个字符串与一个编码树，用编码树将文本编码并返回一个包括编码位序列的 Queue<Bit>

2. **void flattenTree(EncodingTreeNode\* tree, Queue<Bit>& treeShape, Queue<char>& treeLeaves)**
   将给定的树平铺为一个 Queue<Bit>和 Queue<char>

3. **EncodingTreeNode\* buildHuffmanTree(string text)**
   buildHuffmanTree 函数是整个程序的核心。它接受输入文本并遵循 huffman 算法构建一个针对输入文本的最优 huffman 编码树。

4. **EncodedData compress(string messageText)**
   将给定的文本用 huffman 编码压缩，产生一个包括编码信息与编码树的编码数据。

### 运行程序

运行程序，当主菜单提示运行哪些测试时，选择 0（无）。现在主程序进入一个简单的控制台程序，允许你选择要压缩或解压缩的文件。起始项目包含一个你可以用来试验解压缩功能的压缩文件。

当提示你输入文件名时，指定相对于项目文件夹的名称，例如 `res/mystery.jpg.huf`（Windows 使用反斜杠 `res\mystery.jpg.huf`）。未压缩版本将被写入名为 `res/unhuf.mystery.jpg` 的文件。打开未压缩的文件以确认你成功地还原了原始文件。真是太神奇了！

**其他**

- 个别函数如 decode，unflatten 等，假设输入是有效且格式正确的。
- 能够处理任何字符组成的输入，而不仅仅是字母、数字等。许多文件，尤其是包含非文本数据（如声音和图像）的文件，使用了从 0 到 255 的所有可能字符值，因此不得限制可接受字符的范围。
- 要压缩的输入必须包含至少两个不同的字符，以使霍夫曼编码可行。
